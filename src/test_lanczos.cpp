#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
#include <iomanip>
#include <cstdlib>
#include <string>
#include <chrono>
#include <functional>
#include <random>
#include <fstream>

#include "lanczos.h"
#include "construct_ham.h"

// Helper function to generate a small pyrochlore test case
void generate_pyrochlore_test_case() {
    // Generate a small pyrochlore lattice (1x1x1 unit cell)
    std::string cmd = "python3 util/helper_pyrochlore.py --Jxx 1.0 --Jyy 1.0 --Jzz 1.0 --h 0.5 --hx 1.0 --hy 0.0 --hz 0.0 --outdir pyrochlore_test --dim1 2 --dim2 1 --dim3 1 --pbc 0";
    int result = system(cmd.c_str());
    if (result != 0) {
        std::cerr << "Failed to generate pyrochlore test case!" << std::endl;
        exit(1);
    }
}

// Helper function to load the Hamiltonian operator
Operator load_hamiltonian(int& N) {
    // Create an operator with 4 sites (1x1x1 unit cell with 4 sites)
    Operator H(8);
    
    // Load interaction terms from the files generated by helper_pyrochlore.py
    H.loadFromInterAllFile("pyrochlore_test/InterAll.dat");
    H.loadFromFile("pyrochlore_test/Trans.dat");
    
    // The Hilbert space dimension is 2^n_sites
    N = 1 << 8; // 2^4 = 16
    
    return H;
}

// Helper function to apply the Hamiltonian operator to a vector
void apply_hamiltonian(const Complex* in_vec, Complex* out_vec, int N, const Operator& H) {
    // Convert raw arrays to std::vector
    std::vector<Complex> in(in_vec, in_vec + N);
    std::vector<Complex> out = H.apply(in);
    
    // Copy back to output array
    std::copy(out.begin(), out.end(), out_vec);
}

// Helper function to compare two sets of eigenvalues
bool compare_eigenvalues(const std::vector<double>& ref_evals, const std::vector<double>& test_evals, double tol) {
    if (ref_evals.size() != test_evals.size()) {
        std::cout << "Number of eigenvalues doesn't match: " 
                  << ref_evals.size() << " vs " << test_evals.size() << std::endl;
        return false;
    }
    
    double max_diff = 0.0;
    for (size_t i = 0; i < ref_evals.size(); i++) {
        double diff = std::abs(ref_evals[i] - test_evals[i]);
        max_diff = std::max(max_diff, diff);
        if (diff > tol) {
            std::cout << "Eigenvalue mismatch at index " << i << ": " 
                      << ref_evals[i] << " vs " << test_evals[i] 
                      << " (diff = " << diff << ")" << std::endl;
            return false;
        }
    }
    
    std::cout << "Eigenvalues match within tolerance " << tol 
              << " (max diff: " << max_diff << ")" << std::endl;
    return true;
}

// Helper function to print eigenvalues to file
void write_eigenvalues_to_file(const std::vector<double>& eigenvalues, const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error: Unable to open file " << filename << std::endl;
        return;
    }
    
    file << "# Eigenvalues\n";
    for (const auto& eval : eigenvalues) {
        file << std::setprecision(16) << eval << "\n";
    }
    file.close();
}

// Main test function
int main() {
    std::cout << "==== Testing Lanczos methods against direct diagonalization ====" << std::endl;
    
    // Generate test case
    std::cout << "Generating pyrochlore test case..." << std::endl;
    generate_pyrochlore_test_case();
    
    // Load Hamiltonian
    int N;
    std::cout << "Loading Hamiltonian..." << std::endl;
    Operator H = load_hamiltonian(N);
    
    // Create Hamiltonian application function
    std::function<void(const Complex*, Complex*, int)> ham_apply = 
        [&H](const Complex* in, Complex* out, int dim) {
            apply_hamiltonian(in, out, dim, H);
        };
    
    // Reference: Full diagonalization
    std::cout << "\n==== Reference: Full diagonalization ====" << std::endl;
    std::vector<double> ref_eigenvalues;
    std::string ref_dir = "pyrochlore_test/full_diag";
    system("mkdir -p pyrochlore_test/full_diag");
    
    auto start = std::chrono::high_resolution_clock::now();
    full_diagonalization(ham_apply, N, ref_eigenvalues, ref_dir, true);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Full diagonalization completed in " << duration << " ms" << std::endl;
    std::cout << "Found " << ref_eigenvalues.size() << " eigenvalues" << std::endl;
    
    // Print a few eigenvalues
    std::cout << "First few eigenvalues: ";
    for (size_t i = 0; i < std::min(size_t(5), ref_eigenvalues.size()); i++) {
        std::cout << ref_eigenvalues[i] << " ";
    }
    std::cout << std::endl;
    
    write_eigenvalues_to_file(ref_eigenvalues, ref_dir + "/eigenvalues.txt");
    
    // Parameters for Lanczos methods
    int max_iter = N;
    int num_eigs = N;  // Number of eigenvalues to compute
    double tol = 1e-10;
    
    // Test each Lanczos method
    
    // 1. Basic Lanczos
    std::cout << "\n==== Testing basic Lanczos ====" << std::endl;
    std::vector<double> lanczos_eigenvalues;
    std::string lanczos_dir = "pyrochlore_test/lanczos";
    system("mkdir -p pyrochlore_test/lanczos");
    
    start = std::chrono::high_resolution_clock::now();
    lanczos(ham_apply, N, max_iter, num_eigs, tol, lanczos_eigenvalues, lanczos_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Lanczos completed in " << duration << " ms" << std::endl;
    compare_eigenvalues(
        std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
        lanczos_eigenvalues, 
        tol);
    write_eigenvalues_to_file(lanczos_eigenvalues, lanczos_dir + "/eigenvalues.txt");
    
    // 2. Lanczos without orthogonalization
    std::cout << "\n==== Testing Lanczos without orthogonalization ====" << std::endl;
    std::vector<double> lanczos_no_ortho_eigenvalues;
    std::string lanczos_no_ortho_dir = "pyrochlore_test/lanczos_no_ortho";
    system("mkdir -p pyrochlore_test/lanczos_no_ortho");
    
    start = std::chrono::high_resolution_clock::now();
    lanczos_no_ortho(ham_apply, N, max_iter, num_eigs, tol, lanczos_no_ortho_eigenvalues, lanczos_no_ortho_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Lanczos without orthogonalization completed in " << duration << " ms" << std::endl;
    compare_eigenvalues(
        std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
        lanczos_no_ortho_eigenvalues, 
        tol);
    write_eigenvalues_to_file(lanczos_no_ortho_eigenvalues, lanczos_no_ortho_dir + "/eigenvalues.txt");
    
    // 3. Lanczos with selective reorthogonalization
    std::cout << "\n==== Testing Lanczos with selective reorthogonalization ====" << std::endl;
    std::vector<double> lanczos_sel_reorth_eigenvalues;
    std::string lanczos_sel_reorth_dir = "pyrochlore_test/lanczos_sel_reorth";
    system("mkdir -p pyrochlore_test/lanczos_sel_reorth");
    
    start = std::chrono::high_resolution_clock::now();
    lanczos_selective_reorth(ham_apply, N, max_iter, num_eigs, tol, lanczos_sel_reorth_eigenvalues, lanczos_sel_reorth_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Lanczos with selective reorthogonalization completed in " << duration << " ms" << std::endl;
    compare_eigenvalues(
        std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
        lanczos_sel_reorth_eigenvalues, 
        tol);
    write_eigenvalues_to_file(lanczos_sel_reorth_eigenvalues, lanczos_sel_reorth_dir + "/eigenvalues.txt");
    
    // 4. Block Lanczos
    std::cout << "\n==== Testing Block Lanczos ====" << std::endl;
    std::vector<double> block_lanczos_eigenvalues;
    std::string block_lanczos_dir = "pyrochlore_test/block_lanczos";
    system("mkdir -p pyrochlore_test/block_lanczos");
    
    // start = std::chrono::high_resolution_clock::now();
    // block_lanczos(ham_apply, N, max_iter, num_eigs, tol, block_lanczos_eigenvalues, block_lanczos_dir, true, 2);
    // end = std::chrono::high_resolution_clock::now();
    // duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    // std::cout << "Block Lanczos completed in " << duration << " ms" << std::endl;
    // compare_eigenvalues(
    //     std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
    //     block_lanczos_eigenvalues, 
    //     tol);
    // write_eigenvalues_to_file(block_lanczos_eigenvalues, block_lanczos_dir + "/eigenvalues.txt");
    
    // 5. Chebyshev filtered Lanczos
    std::cout << "\n==== Testing Chebyshev filtered Lanczos ====" << std::endl;
    std::vector<double> cheb_lanczos_eigenvalues;
    std::string cheb_lanczos_dir = "pyrochlore_test/cheb_lanczos";
    system("mkdir -p pyrochlore_test/cheb_lanczos");
    
    start = std::chrono::high_resolution_clock::now();
    chebyshev_filtered_lanczos(ham_apply, N, max_iter, num_eigs, tol, cheb_lanczos_eigenvalues);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Chebyshev filtered Lanczos completed in " << duration << " ms" << std::endl;
    compare_eigenvalues(
        std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
        cheb_lanczos_eigenvalues, 
        tol);
    write_eigenvalues_to_file(cheb_lanczos_eigenvalues, cheb_lanczos_dir + "/eigenvalues.txt");
    
    // 6. Shift-invert Lanczos
    double sigma = ref_eigenvalues[num_eigs/2]; // Target middle of the spectrum
    
    std::cout << "\n==== Testing Shift-invert Lanczos ====" << std::endl;
    std::vector<double> shift_invert_eigenvalues;
    std::string shift_invert_dir = "pyrochlore_test/shift_invert";
    system("mkdir -p pyrochlore_test/shift_invert");
    
    start = std::chrono::high_resolution_clock::now();
    shift_invert_lanczos(ham_apply, N, max_iter, num_eigs, sigma, tol, shift_invert_eigenvalues, shift_invert_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Shift-invert Lanczos completed in " << duration << " ms" << std::endl;
    std::cout << "Note: Shift-invert targets eigenvalues close to " << sigma << ", results may differ from reference" << std::endl;
    write_eigenvalues_to_file(shift_invert_eigenvalues, shift_invert_dir + "/eigenvalues.txt");
    
    // 7. Robust Shift-invert Lanczos
    std::cout << "\n==== Testing Robust Shift-invert Lanczos ====" << std::endl;
    std::vector<double> robust_shift_invert_eigenvalues;
    std::string robust_shift_invert_dir = "pyrochlore_test/robust_shift_invert";
    system("mkdir -p pyrochlore_test/robust_shift_invert");
    
    start = std::chrono::high_resolution_clock::now();
    shift_invert_lanczos_robust(ham_apply, N, max_iter, num_eigs, sigma, tol, robust_shift_invert_eigenvalues, robust_shift_invert_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Robust Shift-invert Lanczos completed in " << duration << " ms" << std::endl;
    std::cout << "Note: Shift-invert targets eigenvalues close to " << sigma << ", results may differ from reference" << std::endl;
    write_eigenvalues_to_file(robust_shift_invert_eigenvalues, robust_shift_invert_dir + "/eigenvalues.txt");
    
    // 8. Krylov-Schur
    std::cout << "\n==== Testing Krylov-Schur ====" << std::endl;
    std::vector<double> krylov_schur_eigenvalues;
    std::string krylov_schur_dir = "pyrochlore_test/krylov_schur";
    system("mkdir -p pyrochlore_test/krylov_schur");
    
    start = std::chrono::high_resolution_clock::now();
    krylov_schur(ham_apply, N, max_iter, num_eigs, tol, krylov_schur_eigenvalues, krylov_schur_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Krylov-Schur completed in " << duration << " ms" << std::endl;
    compare_eigenvalues(
        std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
        krylov_schur_eigenvalues, 
        tol);
    write_eigenvalues_to_file(krylov_schur_eigenvalues, krylov_schur_dir + "/eigenvalues.txt");
    
    // 9. Implicitly Restarted Lanczos
    std::cout << "\n==== Testing Implicitly Restarted Lanczos ====" << std::endl;
    std::vector<double> ir_lanczos_eigenvalues;
    std::string ir_lanczos_dir = "pyrochlore_test/ir_lanczos";
    system("mkdir -p pyrochlore_test/ir_lanczos");
    
    start = std::chrono::high_resolution_clock::now();
    implicitly_restarted_lanczos(ham_apply, N, max_iter, num_eigs, tol, ir_lanczos_eigenvalues, ir_lanczos_dir, true);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    std::cout << "Implicitly Restarted Lanczos completed in " << duration << " ms" << std::endl;
    compare_eigenvalues(
        std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
        ir_lanczos_eigenvalues, 
        tol);
    write_eigenvalues_to_file(ir_lanczos_eigenvalues, ir_lanczos_dir + "/eigenvalues.txt");
    
    // 10. ARPACK diagonalization
    // std::cout << "\n==== Testing ARPACK diagonalization ====" << std::endl;
    // std::vector<double> arpack_eigenvalues;
    // std::string arpack_dir = "pyrochlore_test/arpack";
    // system("mkdir -p pyrochlore_test/arpack");
    
    // start = std::chrono::high_resolution_clock::now();
    // arpack_diagonalization(ham_apply, N, max_iter, num_eigs, tol, arpack_eigenvalues, arpack_dir, true);
    // end = std::chrono::high_resolution_clock::now();
    // duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    
    // std::cout << "ARPACK diagonalization completed in " << duration << " ms" << std::endl;
    // compare_eigenvalues(
    //     std::vector<double>(ref_eigenvalues.begin(), ref_eigenvalues.begin() + num_eigs),
    //     arpack_eigenvalues, 
    //     tol);
    // write_eigenvalues_to_file(arpack_eigenvalues, arpack_dir + "/eigenvalues.txt");
    
    // Note: Testing these heavy solvers is optional and commented out by default
    // 11. Spectrum slicing solver
    bool test_heavy_solvers = false;
    if (test_heavy_solvers) {
        std::cout << "\n==== Testing Spectrum slicing solver ====" << std::endl;
        std::vector<double> spectrum_slicing_eigenvalues;
        std::string spectrum_slicing_dir = "pyrochlore_test/spectrum_slicing";
        system("mkdir -p pyrochlore_test/spectrum_slicing");
        
        start = std::chrono::high_resolution_clock::now();
        spectrum_slicing_solver(ham_apply, N, spectrum_slicing_eigenvalues, spectrum_slicing_dir, true, tol);
        end = std::chrono::high_resolution_clock::now();
        duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        
        std::cout << "Spectrum slicing solver completed in " << duration << " ms" << std::endl;
        compare_eigenvalues(ref_eigenvalues, spectrum_slicing_eigenvalues, tol);
        write_eigenvalues_to_file(spectrum_slicing_eigenvalues, spectrum_slicing_dir + "/eigenvalues.txt");
        
        // 12. Optimal spectrum solver
        std::cout << "\n==== Testing Optimal spectrum solver ====" << std::endl;
        std::vector<double> optimal_spectrum_eigenvalues;
        std::string optimal_spectrum_dir = "pyrochlore_test/optimal_spectrum";
        system("mkdir -p pyrochlore_test/optimal_spectrum");
        
        start = std::chrono::high_resolution_clock::now();
        optimal_spectrum_solver(ham_apply, N, optimal_spectrum_eigenvalues, optimal_spectrum_dir, true, tol);
        end = std::chrono::high_resolution_clock::now();
        duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        
        std::cout << "Optimal spectrum solver completed in " << duration << " ms" << std::endl;
        compare_eigenvalues(ref_eigenvalues, optimal_spectrum_eigenvalues, tol);
        write_eigenvalues_to_file(optimal_spectrum_eigenvalues, optimal_spectrum_dir + "/eigenvalues.txt");
    }
    
    std::cout << "\n==== All tests completed ====" << std::endl;
    std::cout << "Results saved in pyrochlore_test/* directories" << std::endl;
    
    return 0;
}